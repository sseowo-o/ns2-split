import { __extends } from "tslib";
import React from 'react';
import { scaleTime } from 'd3-scale';
import { Slider, Rail, Handles, Tracks, Ticks } from 'react-compound-slider';
import { format, addHours, startOfToday, endOfToday, differenceInMilliseconds, isBefore, isAfter, addMinutes, } from 'date-fns';
import SliderRail from './SliderRail';
import Track from './Track';
import Tick from './Tick';
import Handle from './Handle';
import { TimeRangeContainer } from './StyledComponents';
var defaultProps = {
    timelineInterval: [startOfToday(), endOfToday()],
    selectedInterval: [new Date(), addHours(new Date(), 1)],
    disabledIntervals: [],
    containerClassName: '',
    step: 1000 * 60 * 30,
    ticksNumber: 48,
    error: false,
    mode: 3,
    formatTick: function (ms) { return format(new Date(ms), 'HH:mm'); },
    showNow: true,
    onChangeCallback: function () { return 'Change callback not set'; },
    onUpdateCallback: function () { return 'Update callback not set'; },
};
var getTimelineConfig = function (timelineStart, timelineLength) { return function (date, idPrefix) {
    var percent = (differenceInMilliseconds(date, timelineStart) / timelineLength) * 100;
    var value = Number(format(date, 'T'));
    var id = "".concat(idPrefix, "-").concat(value);
    return { id: id, percent: percent, value: value };
}; };
var getFormattedBlockedIntervals = function (blockedDates, _a) {
    if (blockedDates === void 0) { blockedDates = []; }
    var startTime = _a[0], endTime = _a[1];
    if (!blockedDates.length)
        return null;
    var timelineLength = differenceInMilliseconds(endTime, startTime);
    var getConfig = getTimelineConfig(startTime, timelineLength);
    var formattedBlockedDates = blockedDates.map(function (interval, index) {
        var start = interval.start, end = interval.end;
        var color = interval.color;
        if (isBefore(start, startTime))
            start = startTime;
        if (isAfter(end, endTime))
            end = endTime;
        var source = getConfig(start, 'blocked-start');
        var target = getConfig(end, 'blocked-end');
        return { id: "blocked-track-".concat(index), source: source, target: target, color: color };
    });
    return formattedBlockedDates;
};
var getNowConfig = function (_a) {
    var startTime = _a[0], endTime = _a[1];
    var timelineLength = differenceInMilliseconds(endTime, startTime);
    var getConfig = getTimelineConfig(startTime, timelineLength);
    var source = getConfig(new Date(), 'now-start');
    var target = getConfig(addMinutes(new Date(), 1), 'now-end');
    return { id: 'now-track', source: source, target: target };
};
var TimeRange = /** @class */ (function (_super) {
    __extends(TimeRange, _super);
    function TimeRange() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onChange = function (newTime) {
            var formattedNewTime = newTime.map(function (t) { return new Date(t); });
            if (_this.props.onChangeCallback) {
                _this.props.onChangeCallback([formattedNewTime[0], formattedNewTime[1]]);
            }
        };
        _this.checkIsSelectedIntervalNotValid = function (_a, source, target) {
            var start = _a[0], end = _a[1];
            var startInterval = source.value;
            var endInterval = target.value;
            if ((startInterval > start && endInterval <= end) || (startInterval >= start && endInterval < end))
                return true;
            if (start >= startInterval && end <= endInterval)
                return true;
            var isStartInBlockedInterval = start > startInterval && start < endInterval && end >= endInterval;
            var isEndInBlockedInterval = end < endInterval && end > startInterval && start <= startInterval;
            return isStartInBlockedInterval || isEndInBlockedInterval;
        };
        _this.onUpdate = function (newTime) {
            var onUpdateCallback = _this.props.onUpdateCallback;
            var disabledIntervals = _this.disabledIntervals;
            if (!onUpdateCallback) {
                return;
            }
            if (disabledIntervals === null || disabledIntervals === void 0 ? void 0 : disabledIntervals.length) {
                var isValuesNotValid = disabledIntervals.some(function (_a) {
                    var source = _a.source, target = _a.target;
                    return _this.checkIsSelectedIntervalNotValid([newTime[0], newTime[1]], source, target);
                });
                var formattedNewTime_1 = newTime.map(function (t) { return new Date(t); });
                onUpdateCallback({ error: isValuesNotValid, time: formattedNewTime_1 });
                return;
            }
            var formattedNewTime = newTime.map(function (t) { return new Date(t); });
            onUpdateCallback({ error: false, time: formattedNewTime });
        };
        _this.getDateTicks = function () {
            var _a = _this.props, timelineInterval = _a.timelineInterval, ticksNumber = _a.ticksNumber;
            return scaleTime()
                .domain(timelineInterval !== null && timelineInterval !== void 0 ? timelineInterval : [startOfToday(), endOfToday()])
                .ticks(ticksNumber)
                .map(function (t) { return +t; });
        };
        return _this;
    }
    Object.defineProperty(TimeRange.prototype, "disabledIntervals", {
        get: function () {
            var _a;
            return getFormattedBlockedIntervals(this.props.disabledIntervals, (_a = this.props.timelineInterval) !== null && _a !== void 0 ? _a : [startOfToday(), endOfToday()]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeRange.prototype, "now", {
        get: function () {
            var _a;
            return getNowConfig((_a = this.props.timelineInterval) !== null && _a !== void 0 ? _a : [startOfToday(), endOfToday()]);
        },
        enumerable: false,
        configurable: true
    });
    TimeRange.prototype.render = function () {
        var _this = this;
        var _a = this.props, _b = _a.timelineInterval, timelineInterval = _b === void 0 ? defaultProps.timelineInterval : _b, _c = _a.selectedInterval, selectedInterval = _c === void 0 ? defaultProps.selectedInterval : _c, _d = _a.containerClassName, containerClassName = _d === void 0 ? defaultProps.containerClassName : _d, _e = _a.error, error = _e === void 0 ? defaultProps.error : _e, _f = _a.step, step = _f === void 0 ? defaultProps.step : _f, _g = _a.showNow, showNow = _g === void 0 ? defaultProps.showNow : _g, _h = _a.formatTick, formatTick = _h === void 0 ? defaultProps.formatTick : _h;
        var domain = (timelineInterval !== null && timelineInterval !== void 0 ? timelineInterval : [startOfToday(), endOfToday()]).map(function (t) { return Number(t); });
        var disabledIntervals = this.disabledIntervals;
        return (React.createElement(TimeRangeContainer, { className: containerClassName },
            React.createElement(Slider, { step: step, domain: domain.map(function (t) { return +t; }), onUpdate: this.onUpdate, onChange: this.onChange, values: (selectedInterval !== null && selectedInterval !== void 0 ? selectedInterval : [new Date(), addHours(new Date(), 1)]).map(function (t) { return +t; }), rootStyle: { position: 'relative', width: '100%' } },
                React.createElement(Rail, null, function (_a) {
                    var getRailProps = _a.getRailProps;
                    return React.createElement(SliderRail, { getRailProps: getRailProps });
                }),
                React.createElement(Handles, null, function (_a) {
                    var handles = _a.handles, getHandleProps = _a.getHandleProps;
                    return (React.createElement(React.Fragment, null, handles.map(function (handle) { return (React.createElement(Handle, { error: error !== null && error !== void 0 ? error : false, key: handle.id, handle: handle, domain: domain, getHandleProps: getHandleProps })); })));
                }),
                React.createElement(Tracks, { left: false, right: false }, function (_a) {
                    var tracks = _a.tracks, getTrackProps = _a.getTrackProps;
                    return (React.createElement(React.Fragment, null, tracks === null || tracks === void 0 ? void 0 : tracks.map(function (_a) {
                        var id = _a.id, source = _a.source, target = _a.target;
                        return (React.createElement(Track, { error: error !== null && error !== void 0 ? error : false, key: id, source: source, target: target, getTrackProps: getTrackProps }));
                    })));
                }),
                (disabledIntervals === null || disabledIntervals === void 0 ? void 0 : disabledIntervals.length) && (React.createElement(Tracks, { left: false, right: false }, function (_a) {
                    var getTrackProps = _a.getTrackProps;
                    return (React.createElement(React.Fragment, null, disabledIntervals.map(function (_a) {
                        var id = _a.id, source = _a.source, target = _a.target, color = _a.color;
                        return (React.createElement(Track, { error: error !== null && error !== void 0 ? error : false, key: id, source: source, target: target, getTrackProps: getTrackProps, disabled: true, color: color }));
                    })));
                })),
                showNow && (React.createElement(Tracks, { left: false, right: false }, function (_a) {
                    var _b, _c, _d;
                    var getTrackProps = _a.getTrackProps;
                    return (React.createElement(Track, { error: error !== null && error !== void 0 ? error : false, key: (_b = _this.now) === null || _b === void 0 ? void 0 : _b.id, source: (_c = _this.now) === null || _c === void 0 ? void 0 : _c.source, target: (_d = _this.now) === null || _d === void 0 ? void 0 : _d.target, getTrackProps: getTrackProps }));
                })),
                React.createElement(Ticks, { values: this.getDateTicks() }, function (_a) {
                    var ticks = _a.ticks;
                    return (React.createElement(React.Fragment, null, ticks.map(function (tick) { return (React.createElement(Tick, { key: tick.id, tick: tick, count: ticks.length, format: formatTick !== null && formatTick !== void 0 ? formatTick : (function (ms) { return format(new Date(ms), 'HH:mm'); }) })); })));
                }))));
    };
    TimeRange.defaultProps = {
        timelineInterval: [startOfToday(), endOfToday()],
        selectedInterval: [new Date(), addHours(new Date(), 1)],
        disabledIntervals: [],
        containerClassName: '',
        step: 1000 * 60 * 30,
        ticksNumber: 48,
        error: false,
        mode: 3,
        formatTick: function (ms) { return format(new Date(ms), 'HH:mm'); },
        showNow: true,
    };
    return TimeRange;
}(React.Component));
TimeRange.defaultProps = defaultProps;
export default TimeRange;
//# sourceMappingURL=App.js.map